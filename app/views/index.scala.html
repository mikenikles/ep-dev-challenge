
@main() {
    
	<div class="alert alert-info">
		<h4 class="alert-heading">This is a visualization of the EP Dev Challenge!</h4>
		See <a href="http://www.epdeveloperchallenge.com/">http://www.epdeveloperchallenge.com/</a> for more details.
	</div>

    <p>
    	<button class="btn btn-success" type="submit" id="initMaze">Init Maze</button>
    </p>

	<div id="onSuccess" class="alert alert-success">
	    <p>
	        <strong>Done!</strong>
	        <span></span>
	    </p>
	</div>
	<div id="onError" class="alert alert-error">
	    <p>
	        <strong>Oops!</strong>
	        <span></span>
	    </p>
	</div>


	<div class="accordion-group">
		<div class="accordion-heading">
			<a class="accordion-toggle" data-toggle="collapse"
				data-parent="#accordion2" href="#collapseSettings"> Settings</a>
		</div>
		<div id="collapseSettings" class="accordion-body in collapse"
			style="height: auto;">
			<div class="accordion-inner">
				<label class="checkbox"><input id="mazeAutopilot" type="checkbox"> Autopilot</label><br />
				<label class="checkbox"><input id="mazeEnableScrollSpy" type="checkbox"> Automatic scrolling</label><br />
				<label class="checkbox"><input id="mazeStopAtDeadEnds" type="checkbox"> Stop at dead ends</label><br />
			</div>
		</div>
	</div>

	<div class="accordion-group">
		<div class="accordion-heading">
			<a class="accordion-toggle" data-toggle="collapse"
				data-parent="#accordion2" href="#collapseStatistics"> Statistics</a>
		</div>
		<div id="collapseStatistics" class="accordion-body in collapse"
			style="height: auto;">
			<div class="accordion-inner">
				Current cell: <a href="#"><span id="statsCurrentCell">0</span></a><br />
				Total moves: <span id="statsTotalMoves">0</span><br />
				Total invalid moves: <span id="statsTotalInvalidMoves">0</span><br />
				Total intersections: <span id="statsTotalIntersections">0</span><br />
				Total deadEnds: <span id="statsTotalDeadEnds">0</span><br />
			</div>
		</div>
	</div>

	<div class="alert alert-info">
	    <p>
			<strong>Solving maze:</strong> <span id="mazeGUID">Not started yet</span>
	    </p>
	</div>

	<p>	
	</p>

    <div id="maze"></div>


    <script type="text/javascript" charset="utf-8">
    	
    
	    $(function() {
	    	// Globals
	    	var mazeSocket;
	    	var maxRow = 50;
	    	var maxColumn = 50;
	    	var previousCellId = '#0-0';
	    	var currentCellId = '';
	    	var isSolveMazeAutomatically = false;
	    	var intersectionCellIds = [];
	    	
	    	// Statistics
	    	var statisticsTotalMoves = 0;
	    	var statisticsTotalInvalidMoves = 0;
	    	var statisticsTotalIntersections = 0;
	    	var statisticsTotalDeadEnds = 0;

	    	$("#onError").hide();
	    	$("#onSuccess").hide();
	    	
	    	$(".collapse").collapse();
	    	
	    	var getCellId = function(x, y) {
	    		return '#' + x + '-' + y;
	    	}
	    	
	    	var setCellData = function(cellId, currentCellData) {
	    		$(cellId).attr('data-note', currentCellData.note);
	    		$(cellId).attr('data-atEnd', currentCellData.atEnd);
	    		$(cellId).attr('data-previouslyVisited', currentCellData.previouslyVisited);
	    		$(cellId).attr('data-north', currentCellData.north);
	    		$(cellId).attr('data-east', currentCellData.east);
	    		$(cellId).attr('data-south', currentCellData.south);
	    		$(cellId).attr('data-west', currentCellData.west);
	    	}
	    	
	    	var setCellBorders = function(cellId) {
	    		var directionNorth = $(cellId).attr('data-north');
	    		var directionEast = $(cellId).attr('data-east');
	    		var directionSouth = $(cellId).attr('data-south');
	    		var directionWest = $(cellId).attr('data-west');
	    		
	    		if('BLOCKED' == directionNorth) {
	    			$(cellId).css('border-top-color','black');
	    		}
	    		if('BLOCKED' == directionEast) {
	    			$(cellId).css('border-right-color','black');
	    		}
	    		if('BLOCKED' == directionSouth) {
	    			$(cellId).css('border-bottom-color','black');
	    		}
	    		if('BLOCKED' == directionWest) {
	    			$(cellId).css('border-left-color','black');
	    		}
	    	}
	    	
	    	var isCellDeadEnd = function(cellId) {
	    		var directionNorth = $(cellId).attr('data-north');
	    		var directionEast = $(cellId).attr('data-east');
	    		var directionSouth = $(cellId).attr('data-south');
	    		var directionWest = $(cellId).attr('data-west');
	    		
	    		if('UNEXPLORED' == directionNorth) {
	    			return false;
	    		}
	    		if('UNEXPLORED' == directionEast) {
	    			return false;
	    		}
	    		if('UNEXPLORED' == directionSouth) {
	    			return false;
	    		}
	    		if('UNEXPLORED' == directionWest) {
	    			return false;
	    		}
	    		return true;
	    	}
	    	
	    	var isCellMoveOnOk = function(cellId) {
	    		// An intersection is defined by more than 1 UNEXPLORED direction
	    		var directionNorth = $(cellId).attr('data-north');
	    		var directionEast = $(cellId).attr('data-east');
	    		var directionSouth = $(cellId).attr('data-south');
	    		var directionWest = $(cellId).attr('data-west');

	    		if('UNEXPLORED' == directionNorth) {
	    			return true;
	    		}
	    		if('UNEXPLORED' == directionEast) {
	    			return true;
	    		}
	    		if('UNEXPLORED' == directionSouth) {
	    			return true;
	    		}
	    		if('UNEXPLORED' == directionWest) {
	    			return true;
	    		}
	    		return false;
	    	}
	    	
	    	var cellActionJump = function() {
	    		var x = $(this).attr('data-x');
	    		var y = $(this).attr('data-y');
	    		console.log('About to jump to x:' + x + '; y: ' + y);
	    		
	    		// Send 'jump' event to server with current coordinates
	    		mazeSocket.send(JSON.stringify(
	    				{ type: 'jump', x: x, y: y }
	    		));
	    	}
	    	
	    	var cellActionMove = function(event) {
	    		// Prevent other events on this cell from being fired
	    		event.stopImmediatePropagation();
	    		
	    		//setNeighboringCellActions($(this).attr('id'));
	    		var moveDirection = $(this).attr('data-move-direction');

	    		cellActionMoveForKeyboard(moveDirection);
	    	}
	    	
	    	var cellActionMoveForKeyboard = function(moveDirection) {
	    		statisticsTotalMoves++;
	    		
	    		var x = $(currentCellId).attr('data-x');
	    		var y = $(currentCellId).attr('data-y');
	    		console.log('About to move '+ moveDirection +' from x:' + x + '; y: ' + y);

	    		// Send 'move' event to server with current coordinates
	    		mazeSocket.send(JSON.stringify(
	    				{ type: 'move', direction: moveDirection }
	    		));
	    	}
	    	
	    	var isCellAnIntersection = function(cellId) {
	    		// An intersection is defined by more than 1 UNEXPLORED direction
	    		var directionNorth = $(cellId).attr('data-north');
	    		var directionEast = $(cellId).attr('data-east');
	    		var directionSouth = $(cellId).attr('data-south');
	    		var directionWest = $(cellId).attr('data-west');
	    		var directionsCount = 0;
	    		
	    		if('UNEXPLORED' == directionNorth) {
	    			directionsCount++;
	    		}
	    		if('UNEXPLORED' == directionEast) {
	    			directionsCount++;
	    		}
	    		if('UNEXPLORED' == directionSouth) {
	    			directionsCount++;
	    		}
	    		if('UNEXPLORED' == directionWest) {
	    			directionsCount++;
	    		}
	    		
	    		if(directionsCount > 1) {
	    			statisticsTotalIntersections++;
	    			return true;
	    		}
	    		return false;
	    	}
	    	
	    	var updatePathAndIntersectionActions = function(cellId) {
	    		// Current cell is highlighted, depending on whether it's an intersection or not
	    		if(isCellAnIntersection(cellId)) {
		    		$(cellId).addClass('intersection');
		    		
		    		// Let's remember this cell, so we can come back when we reach a dead end
		    		intersectionCellIds.push(cellId);
	    		} else {
		    		$(cellId).addClass('visited');
	    		}
	    	}
	    	
	    	var enableKeyboardShortcuts = function() {
	    		$(document).keyup(function(e) {
	    			e.preventDefault();

		    		if(e.which == 37) {  // Left arrow key code
		    			cellActionMoveForKeyboard('WEST');
	    	        }
	    	        else if(e.which == 38) {  // Up arrow key code
		    			cellActionMoveForKeyboard('NORTH');
	    	        }
	    	        else if(e.which == 39) {  // Right arrow key code
		    			cellActionMoveForKeyboard('EAST');
	    	        }
	    	        else if(e.which == 40) {  // Down arrow key code
		    			cellActionMoveForKeyboard('SOUTH');
	    	        }
	    	    });
	    	}
	    	
	    	var setNeighboringCellActions = function(cellId) {
	    		var cellX = Number($(cellId).attr('data-x'));
	    		var cellY = Number($(cellId).attr('data-y'));
	    		var directionNorth = $(cellId).attr('data-north');
	    		var directionEast = $(cellId).attr('data-east');
	    		var directionSouth = $(cellId).attr('data-south');
	    		var directionWest = $(cellId).attr('data-west');
	    		
	    		// Tuning: We have to reach the exit at cell 50-50 (South-East corner).
	    		//         Let's make sure we always move towards that direction.
	    		if('UNEXPLORED' == directionWest) {
	    			var neighborCellId = getCellId(cellX - 1, cellY);
	    			$(neighborCellId).attr('data-move-direction', 'WEST');
			    	$(neighborCellId).one("click", cellActionMove);
	    		}
	    		if('UNEXPLORED' == directionNorth) {
	    			var neighborCellId = getCellId(cellX, cellY - 1);
	    			$(neighborCellId).attr('data-move-direction', 'NORTH');
			    	$(neighborCellId).one("click", cellActionMove);
	    		}
	    		if('UNEXPLORED' == directionSouth) {
	    			var neighborCellId = getCellId(cellX, cellY + 1);
	    			$(neighborCellId).attr('data-move-direction', 'SOUTH');
			    	$(neighborCellId).one("click", cellActionMove);
	    		}
	    		if('UNEXPLORED' == directionEast) {
	    			var neighborCellId = getCellId(cellX + 1, cellY);
	    			$(neighborCellId).attr('data-move-direction', 'EAST');
			    	$(neighborCellId).one("click", cellActionMove);
	    		}
	    	}
	    	
	    	var areCellsNeighbors = function(cellIdOne, cellIdTwo) {
	    		var cellOneX = Number($(cellIdOne).attr('data-x'));
	    		var cellOneY = Number($(cellIdOne).attr('data-y'));
	    		var cellTwoX = Number($(cellIdTwo).attr('data-x'));
	    		var cellTwoY = Number($(cellIdTwo).attr('data-y'));

	    		var isXNeighbor = false;
	    		var xOffset = Number(cellOneX - cellTwoX);
	    		if((xOffset === -1) || (xOffset === 1)) {
	    			isXNeighbor = true;
	    		}
	    		var isYNeighbor = false;
	    		var yOffset = Number(cellOneY - cellTwoY);
	    		if((yOffset == -1) || (yOffset == 1)) {
	    			isYNeighbor = true;
	    		}
	    		return isXNeighbor || isYNeighbor;
	    	}
	    	
	    	var updatePreviousCellVisitedState = function() {
	    		// See where we came from
	    		var previousMoveDirectionAttr = $(currentCellId).attr('data-move-direction');
	    		//console.log('data-move-direction: ' + previousMoveDirectionAttr);
	    		if(previousMoveDirectionAttr == undefined)
	    			return; // First cell doesn't have a move direction
	    		var previousMoveDirection = previousMoveDirectionAttr.toLowerCase();
	    		
	    		// Update previous cell's VISITED state if it's a cell nearby (no updates when we jump)
	    		if(areCellsNeighbors(currentCellId, previousCellId)) {
		    		$(previousCellId).attr('data-' + previousMoveDirection, 'VISITED');
	    		}
	    	}
	    	
	    	var optimizeIdArray = function(cellA, cellB) {
	    		var cellAX = Number($(cellA).attr('data-x'));
	    		var cellAY = Number($(cellA).attr('data-y'));
	    		var cellBX = Number($(cellB).attr('data-x'));
	    		var cellBY = Number($(cellB).attr('data-y'));
	    		
	    		// 1. Priority: Move East
	    		if(cellAY - cellBY == 0) {
	    			return cellAX - cellBX;
	    		}
	    		
	    		// 2. Priority: Move South
	    		if(cellAX - cellBX == 0) {
	    			return cellAY - cellBY;
	    		}
	    		
	    		return 0;
	    	}
	    	
	    	var moveOn = function() {
	    		var cellX = Number($(currentCellId).attr('data-x'));
	    		var cellY = Number($(currentCellId).attr('data-y'));
	    		var directionNorth = $(currentCellId).attr('data-north');
	    		var directionEast = $(currentCellId).attr('data-east');
	    		var directionSouth = $(currentCellId).attr('data-south');
	    		var directionWest = $(currentCellId).attr('data-west');

	    		var neighborCellId = '';
	    		
	    		// Tuning: We have to reach the exit at cell 50-50 (South-East corner).
	    		//         Let's make sure we always move towards that direction.
	    		if('UNEXPLORED' == directionWest) {
	    			neighborCellId = getCellId(cellX - 1, cellY);
	    		}
	    		if('UNEXPLORED' == directionNorth) {
	    			neighborCellId = getCellId(cellX, cellY - 1);
	    		}
	    		if('UNEXPLORED' == directionSouth) {
	    			neighborCellId = getCellId(cellX, cellY + 1);
	    		}
	    		if('UNEXPLORED' == directionEast) {
	    			neighborCellId = getCellId(cellX + 1, cellY);
	    		}

	    		// Reached a dead end
	    		if('' == neighborCellId) {
	    			statisticsTotalDeadEnds++;
	    			console.log('Warning: Reached a dead end at x:' + cellX + '; y: ' + cellY);
	    			
	    			// Mark the cell as a dead end
	    			$(currentCellId).addClass('deadEnd');
	    			
	    			if(isSolveMazeAutomatically && !$('#mazeStopAtDeadEnds').is(':checked')) {
	    				// Tuning: We have to reach the exit at cell 50-50 (South-East corner).
	    				//         Let's sort the intersection IDs and continue from the cell
	    				//         closest to the South-East corner
	    				intersectionCellIds.sort(optimizeIdArray);

	    			
	    				// Check intersections until we find one to continue
	    				var lastIntersectionCellId = intersectionCellIds.pop();
	    				while(lastIntersectionCellId != undefined) {
		    				// If the intersection has still more ways to follow, put it back in the stack
		    				if(isCellMoveOnOk(lastIntersectionCellId)) {
		    					console.log('OK to jump to intersection');
		    					intersectionCellIds.push(lastIntersectionCellId);
		    					
		    					break;
				    			//$(lastIntersectionCellId).trigger('click');
		    				} else {
		    					// An old intersection is in the array. We've already explored all directions.
		    					// Get rid of it and try the next in the stack
		    					lastIntersectionCellId = intersectionCellIds.pop();
		    				}
	    				}
	    				$(lastIntersectionCellId).trigger('click');
	    			} else {
	                    $("#onError span").text('Reached a dead end. Click on an orange intersection to continue.');
	                    $("#onError").fadeIn('slow');
	    			}
	    		} else {
	    			$(neighborCellId).trigger('click');
	    		}
	    	}
	    	
	    	var scrollTo = function(top, left, speed) {
                $('html, body').animate({
					scrollTop: top,
					scrollLeft: left
				}, speed);
	    		
	    	}

	    	var scrollSpy = function() {
	    		if ($("#mazeEnableScrollSpy").is(':checked')) {
	    			var top = $(currentCellId).offset().top - 150;
	    			var left = $(currentCellId).offset().left - 200;
	    			scrollTo(top, left, 100);
	    		}
	    	}
	    	
	    	var scrollToTopLeft = function() {
	    		scrollTo(0, 0, 1000);
	    	}
	    	
	    	var isCompleted = function() {
	    		var isCompleted = $(currentCellId).attr('data-atEnd') == "true";
	    		var note = $(currentCellId).attr('data-note');
	    		
	    		
	    		if(isCompleted) {
	    			$("#onSuccess span").text("That's it, we're out of the maze. Message from EP: " + note);
                	$("#onSuccess").fadeIn('slow');
                	
                	scrollToTopLeft();
	    		}
	    		return isCompleted;
	    	}
	    	
	    	var updateStatistics = function() {
	    		var x = Number($(currentCellId).attr('data-x'));
	    		var y = Number($(currentCellId).attr('data-y'));
	    		$('#statsCurrentCell').text('x: ' + x + '; y: ' + y);
	    		$('#statsTotalMoves').text(statisticsTotalMoves);
	    		$('#statsTotalInvalidMoves').text(statisticsTotalInvalidMoves);
	    		$('#statsTotalIntersections').text(statisticsTotalIntersections);
	    		$('#statsTotalDeadEnds').text(statisticsTotalDeadEnds);
	    	}
	    
	    	var initMaze = function() {
	    		// Initialize WebSocket connection to the server
	        	var WS = window['MozWebSocket'] ? MozWebSocket : WebSocket
	    		mazeSocket = new WS("@routes.EpDevChallenge.maze().webSocketURL(request)")
	    		
		    	// Function to retrieve server messages
		    	mazeSocket.onmessage = receiveEvent;
	    		
	    		// Clear cells' click event
	    		$(".cell").off("click");

	    		// Enable arrow key navigation
		    	enableKeyboardShortcuts();
	    	}
	    	
	    	// Listen to events sent by the server
	    	var receiveEvent = function(event) {
                var data = JSON.parse(event.data)
                console.log('Data received from server: ' + JSON.stringify(data));
                
                // Handle errors
                if(data.error) {
                	if('init' == data.type) {
	                    mazeSocket.close();
                	} else if('move' == data.type) {
                		statisticsTotalInvalidMoves++;
                	}
                    $("#onError span").text(data.error);
                    $("#onError").fadeIn('slow');
                	scrollToTopLeft();
                } else {
                    //console.log(data);
                    console.log('');
                    console.log('NEXT MOVE');
                    console.log('=========');
                    $('#onError').fadeOut('slow');
                    
                    // Add cell data and mark current cell
                    var x = data.ep.currentCell.x;
                    var y = data.ep.currentCell.y;
                    currentCellId = getCellId(x, y);
                    
                    // Scroll spy (make sure we stay focused)
                    scrollSpy();

                    // Update the previous cell making sure it's marked as VISITED
                    updatePreviousCellVisitedState();
                    
                    setCellData(currentCellId, data.ep.currentCell);
                    setCellBorders(currentCellId);
                    setNeighboringCellActions(currentCellId);
                    updatePathAndIntersectionActions(currentCellId);
                    
					// We can jump to every visited cell (remove the "move" click event first)
                    $(currentCellId).off("click");
                    $(currentCellId).on("click", cellActionJump);
                    
                    if('init' == data.type) {
                    	$('#mazeGUID').text(data.ep.currentCell.mazeGuid);
                    	$('#mazeStarted').text(new Date());
                    }
                    
                    // Lastly...
                    previousCellId = currentCellId;
                    
                    // Check if we're done and if so, sit down and get a drink
                    if(isCompleted()) {
		                updateStatistics();
		                mazeSocket.close();
                    	console.log('Done.');
                    	return;
                    }
                    
                    // Proceed programmatically if the autopilot is turned on
                    if (isSolveMazeAutomatically) {
						moveOn();
					}
                }
                // Statistics
                updateStatistics();
            }


	    	// Build maze
	    	for(row=0; row < maxRow; row++) {
	    		$('#maze').append('<div class="row" id="row' + row + '">');
	    		
	    		for(column=0; column < maxColumn; column++) {
	    			var id = getCellId(column, row).substring(1); // Remove leading #
	    			var toolTip = 'x: ' + column + '; y: ' + row;
	    			$('#row' + row).append('<div class="cell span1" rel="tooltip" title="'+toolTip+'" id="' + id + '" data-x="'+column+'" data-y="'+row+'">&nbsp;</div>');
	    		}
	    	}
	    	// Enable cell tooltips
	    	$('#maze').tooltip({
	    		selector: '.cell'
	    	});
	    	
	    	
	    	// Bind init maze button
	    	$('#initMaze').on("click", function() {
	    		initMaze();
	    	});

	    	// Enable auto pilot
	    	$('#mazeAutopilot').on("change", function() {
	    		isSolveMazeAutomatically = !isSolveMazeAutomatically;
    		});
	    	
	    	// Jump to current cell
	    	$('#statsCurrentCell').on("click", function() {
	    		var top = $(currentCellId).offset().top - 150;
	    		var left = $(currentCellId).offset().left - 200;
				scrollTo(top, left, 1000);
	    	});
	    });
    
    </script>
}